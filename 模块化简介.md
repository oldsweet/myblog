ECMAscript标准

- 没有模块化系统
  - 有模块但是缺乏模块化系统
- 标准库少
- 没有标准接口
- 缺乏管理系统

CommonJS规范

1. CommonJS规范的提出，主要是为了弥补当前Javascript没有标准的缺陷

2. CommonJS规范为JS指定了一个美好的愿景，希望JS能够在任何地方运行

3. CommonJS对模块的定义十分简单：

   - 模块引用
   - 模块定义
   - 模块标识

4. 一个js文件就是一个模块，使用require()来引入文件模块

5. 在node中，每个文件的js代码都是独立运行在一个函数中，而不是全局作用域，所以一个模块的中的变量和函数在其他模块中无法访问。可以通过exports来暴露引入文件的属性

   ```javascript
   // 文件1
   exports.x = 10;
   exports.y = 20;
   
   // 文件2
   var md = require("文件01路径");
   
   log(x); // 10
   log(y); // 20
   ```



## 模块化简介

1. 模块的标识

   - 我们使用require()引入外部模块时，使用的就是模块的标识

   - 模块分为两类

     1. 核心模块
        - 核心模块的标识，就是模块的名字
     2. 文件模块
        - 由用户自己创建
        - 文件模块的标识就是文件的路径

   - 在node中有一个全局变量global，它的作用和网页中的window类似，在全局中创建的属性和函数都会在global中保存

   - 每一个模块都是一个函数有5个参数：

     1. exports  - 该对象用来导出模块
     2. require - 该对象用来导入模块
     3. module - 该对象指向本模块
     4. _filename - 指向该模块文件路径
     5. _dirname - 指向该模块的目录路径

   - exports 和 module.exports的区别

     - 通过exports只能使用.的方式向外暴露变量
       - export.xxx = xxxx
     - 而module.exports既可以通过.也可以通过赋值的方式来直接赋值
       - module.exports.xxx = xxx
       - module.exports = {}

   - package

     - CommonJS的包规范允许我们将一组相关的模块组合到一起，形成一组完整的工具

     - CommonJS的包规范由包结构和包描述文件两个部分组成

     - 包结构

       - 用于组织包中的各种文件

       - 包实际上是一个压缩文件，解压后还原成目录。

         - package.json   包描述文件（这是必须的）

           - 位于根目录下，包含一下字段

             ​	![image-20210129133201663](C:\Users\Libaisonm\AppData\Roaming\Typora\typora-user-images\image-20210129133201663.png)

         - bin  可执行二进制文件

         - lib js代码

         - doc 文档

         - test 单元测试

     - 包描述文件

       - 描述包的相关信息，以供外部读取

     ## npm简介

     - node package manager
     - CommonJS包规范是理论，NPM是其中的一种实践
     - 对于Node而言，NPM帮助其完成第三方模块发布，安装和依赖。借助NPM，Node与第三方模块中间形成很好的生态系统
     - npm的命令
       - npm -v 查看npm的版本
       - npm version           --查看npm的版本详情
       - npm search 包名    --搜索包
       - npm install/i 包名  --安装包
       - npm remove/r 包名 --删除包
       - npm install 包名 --save  --安装包并且添加到依赖中 ******
       - npm install 下载当前项目所依赖的包
       - npm install 包名 -g 全局安装包（全局安装的包一般都是一些工具）
     - npm包的搜索
       - node使用模块名字来引入模块时，他会首先在当前目录的node_module中找，如果有则直接使用如果没有则去上一级目录的node_modules中寻找，直到找到根目录。找到就使用没有就直接报错



## 文件系统

- 通过node来操作系统中的文件

- 使用文件系统，需要引入fs模块，fs是核心模块

- 同步和异步调用

- 文件操作步骤

  ```javascript
  // 同步文件的写入
  
  var fs = require("fs");
  //1. 打开文件
  var fd = fs.openSync(path,flags[,mode]);
  	// -path 文件路径
  	// -flags 文件操作类型 -r 只读的 -w 只写的
  	// fd 文件的标识
  //2.写入文件
  	fs.writeSync(fd,content[,position,encoding])
  // -fd 文件的标识
  // -content 文件的内容
  // -position 写入的起始位置
  // -encoding 编码格式，默认utf-8
  
  //3.关闭文件
  	fs.closeSync(fd);
    	// 关闭文件避免内存被占用
  
  
  // 异步文件的写入
  var fs = require("fs");
  // 1.打开文件
  // fs.open(path,flags[,mode],callback)
  var fd = fs.open("./helloworld.txt","w",function(){
      // 回调函数两个参数，第一个为err，第二个为fd
      if(err){
          // 函数出错处理
      }
      // 对文件进行处理
     // 2.写入文件
      fd.write(fd,"helloworld",function(err){
          if(err){
              //错误处理
          }
       //3.关闭文件
         	fd.close(fd,function(err){
              if(err){
                  // 错误处理
              }
          })
      });
  }); // 异步打开
  // fd是undefined，异步的方法没有返回值
  ```

- 简单文件写入

  ```JavaScript
   // fs.writeFile(file,data[,options],callback)
   // fs.writeFileSync(file,data[,options])
    	// -file 要操作的文件路径
    	// -data 要写入的路径
    	// -options 选项，可以对写入进行一些设置
    	// -callback 当写入完成是执行的回调函数
   
  ```

- 流式文件写入

  - 异步，同步，简单文件写入都不适合大文件的写入。性能较差，容易导致内存溢出

  - 流式文件写入

    ```javascript
    // fs.createWriteStream(path[,options]);
    // - 可以用来创建一个可写流
    //  path -文件路径
    // options -配置的参数
    
    // 可以通过监听流的open和close事件来监听流的打开和关闭
    var ws = fs.creatWriteStream("./hello.txt");
    ws.once('open',function(){// on可以长期监听 once一次性的监听
        log("ws打开了")
    })
    ws.write("这个是流式写入方式写入的内容");
    
    // ws.end(); 发送方关闭，这样会保证内容传输完整
    // ws.close(); 接收方关闭
    ```

  - 文件读取

    - 同步文件读取

    - 异步文件读取

    - 简单文件读取

      ```javascript
      // fs.readFile(path[,options],calback);
      // fs.readFileSync(path[,options]);
      var fs = require('fs');
      
      fs.readFile("./hello.txt",(err,data)=>{
          if(err)console.log(err);
          console.log(data.toString()); // 返回一个buffer
      })
      ```

      

    - 流式文件读取

    
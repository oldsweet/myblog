# 第7章 函数表达式

- 函数表达式的特征

- 使用函数实现递归

- 使用闭包定义私有变量

- 定义函数的方式有两种：1.函数声明 2.函数表达式

  ```javascript
  if(condition){
        function sayHi(){alert('hi')}
      }
      else {
        function sayHi(){alert("hello world");};
      }
      // 不要这样做
   // 但是如果这样使用函数表达式就没什么问题了
  ```



## 7.1 递归

- 递归函数是在一个函数通过名字调用自身的情况下构成的。

  ```javascript
  function fac(num){
       if(num == 0)return 1;
       else return num * fac(num - 1);
     }
      //这是一个递归函数
      var anfac = fac;
      fac = null; 
      var res = anfac(10); // err
      alert(res); 
      
      // 解决的第一个方法
      function fac(num){
       if(num == 0)return 1;
       else return arguments.callee(num - 1) * num;
     }
      //这是一个递归函数
      var anfac = fac;
      fac = null; 
      var res = anfac(10); // err
      alert(res);  // 正确使用
      // 在严格模式下，不能通过脚本来访问arguments.callee。
      // 第二种方法
       var fac = (
       function f(num){
         if(num == 0)return 1;
         else return num * f(num - 1);
       }
     );
      f = null;
     alert(fac(10)); 
     // 这种方法可以在严格模式下正常使用
     
       function f(num){
         if(num == 0)return 1;
         else return num * f(num - 1);
       }
       var fac = (f);
       f =null;
       alert(fac(10));  // 这种方法不能正常使用
  ```

  

  ## 7.2 闭包

  1. 闭包是指有权访问另外严格函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数
  2. 当某个函数被第一次调用时，会创建严格执行环境以及相应的作用链，并把作用域链赋值给一个特殊的内部属性[Scope]。然后，使用this.arguments和其他命名参数来初始化函数的活动对象。
  3. 后台的每一个执行环境都有一个表示变量的对象——变量对象。全局环境的对象始终存在。
  4. 在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域中。

  

  ### 7.2.1 闭包和变量

  - 作用域链的这种配置机制引出了一个值得注意的副作用。即闭包只能取得包含函数中任何变量的最后一个值。

    ```javascript
      function createFunctions(){
            var result = new  Array(); // 每一个元素都是一个函数
            for(var i = 0;i < 10;i++){
              result[i] = function(){
                return i;
              }
            }
            return result; 
        }
        var res = createFunctions();
        alert(res[9]()); // 这里的每一个返回都是10，每一个函数都引用保存变量i的一个变量的对象 
    
    // 下面这个才可以正确的符合我们的要求
    function creatFunction(){
         var res = new Array();
         for(var  i = 0;i < 10;i++){
           res[i] = function(){
             return function(){
               return num;
             }
           }(i);  <script>
       function creatFunction(){
         var res = new Array();
         for(var  i = 0;i < 10;i++){
           res[i] = function(num){
             return function(){
               return num;
             }
           }(i);
         }
         return res;
       }
       var res = creatFunction();
       alert(res[2]()); // 2 可以正常使用
         }
         return res;
       }
    var res = creatFunction();
       alert(res[2]()); // 2 可以正常使用
    ```

  

  ### 7.2.2 关于this对象

  - 在闭包中使用this对象有可能导致一些问题

  - 匿名函数执行环境具有全局性，因此this对象通常指向window。

    ```javascript
     var name = 'the window';
        var object = {
          name: 'my obj',
          getNameFunc:function(){
            return function(){ // 闭包 
              return this.name; 
            }
          }
        }
        alert(object.getNameFunc()()); // the window  匿名函数没有获取到对象中的my obj
    ```

  - 在外部作用域中的this对象保存在一个闭包能够访问到的变量里，就可以让闭包访问到该对象了 

    ```javascript
    var name = 'the window';
        var object = {
          name: 'my obj',
          getNameFunc:function(){
            var that = this;
            return function(){ // 闭包 
              return that.name; 
            }
          }
        }
        alert(object.getNameFunc()()); // my obj
    
     var name = 'the window';
      var object = {
        name:'my obj',
        getName:function(){
          return this.name;
        }
      }
      alert(object.getName()); // 'my obj'
      alert((object.getName)()); // 'my obj'
      alert((object.getName = object.getName)()); // the window 
    // 最后的这个this没有得到很好的维护
    ```

    

  ### 7.2.3 内存泄漏

  ```javascript
  function assignHandler(){
        var element =  document.getElementById("someElement");
        element.onclick = function(){
          alert(element.id);
        }
      } 
      // 这个代码无法减少element的引用数，因此element所占的内存永远不会被回收
         function assignHandler(){
        var element =  document.getElementById("someElement");
        var id = element.id;
        element.onclick = function(){
          alert(id);
        }
        id = null
      }
      
      
  ```

  - 闭包会引用包含函数的整个活动对象



## 7.3 模仿块级作用域

```javascript
 function outputNumbers(count){
      for(var i = 0;i < count;i++){
        alert(i);
      }
      var i; // 重新定义，但是仍然不会改变它的值
      alert(i); 
    }
    outputNumbers(10); // 1 - 10

// JavaScript从来不会告诉你你是否多次声明了同一个变量：他会对后面的声明视而不见，但是会执行后面的初始化
// 匿名函数可以用来模仿块级作用域并避免这个问题

(function(){
    // 这里是块级元素作用域 
})(); // == c++中的括号
```



# 7.4 私有变量

- 严格来说，JavaScript中没有私有成员的概念；所有对象属性都是公有的
- 但是有一个私有变量的概念，任何在函数中定义的变量，都可以认为是私有变量

### 7.4.1 静态私有变量

```javascript
 (function(){
      var privateVar = 10;
      function privateFun(){
        return false;
      }

      Myobj = function(){

      };
      Myobj.prototype.publicMethod = function(){
        privateVar++;
        return privateFun();
      }
    })();
// 这个模式创建了一个私有作用域，并在其中封装了一个构造函数和相应的方法

   (function(){
     var name = "";
     Person = function(value){
       name = value;
     };

     Person.prototype.getName = function(){
       return name;
     }
     Person.prototype.setName = function(value){
       name = value;
     }
    })();

    var person1 = new Person('libaisonm');
    alert(person1.getName()); // libaisonm
    person1.setName('sss');
    alert(person1.getName());

    var person2 = new Person('aaaa');
    alert(person1.getName()); // aaaa
    alert(person2.getName()); // aaaa
```




# 第六章 面向对象程序设计

- 连接对象属性
- 理解并创建对象
- 理解继承

## 6.1 理解对象

 - 对象有两种创建对象：1.构造函数 2.字面量

   ### 6.1.1  属性类型

   - JavaScript有两种属性：数据属性和服务器属性

     1. 数据属性：数据属性包含一个数据值的位置

     - [[Configurable]]:表示能否通过delete来删除属性从而重新定义属性，是否可以修改属性的特性，或者是否可以把属性修改为访问器属性。在对象上直接定义的属性的这个特性为true--可以修改

     - [[Enumerable]]:表示能否通过for-in来循环返回

     - [[Writable]]:能否修改属性的值

     - [[Value]]:表示属性的值，默认为undefined

       要修改属性默认的特性，必须使用Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象，属性的名字和一个描述符对象。描述符对象的属性必须是：configurable，enumerable，writable和value。

       ```javascript
       var person = {};
           Object.defineProperty(person,"name",{
              configurable:false,
              value:"libaison",
           });
           delete person.name; // 无效
          person.name = "SSSS";// 无效
           alert(person.name); // libaison
       ```

       在调用该方法的时候，如果不指定。configurable，enumerable和writable的默认值都是false。

       2. 访问器属性

          - 访问器中不包含数据值；他们包含两个函数：getter和setter函数（这两个函数都不是必须的）

            1. Configurable：表示该对象是否可以改动。默认为true
            2. Enumerable：表示是否可以通过for-in循环返回属性。默认为true
            3. Get：在读取属性时调用的函数。默认为undefined
            4. Set：在写入属性时调用的函数。默认为undefined

          - 访问器属性不能直接定义，必须通过Object.defineProperty()来定义。

            ```JavaScript
            var person = {};
               Object.defineProperty(person,"_age",{
                 set:function(val){
                    this.name = val;
                 },
                 get:function(){
                   return "qqqq"; 
                 }
               });
               person._age = "ssss"; // 访问了_age的setter
               alert(person.name);  // sssss
               alert(person._age); // 访问了_age 的getter qqqq
            ```

          - 不一定要同时的指定getter和setter。但是只指定getter意味着不能写。类似的没有setter函数也不能读。

          - 在不支持Object.defineProperty()方法的浏览器中不能修改Configurable和Enumerable

     ### 6.1.2  定义多个属性

     - Object.defineProperties()方法可以一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个要添加和修改其属性的对象

       ```javascript
       var person = {age:10};
          Object.defineProperties(person,{
            name:{value:"libaison"},
            age:{value:10,configurable:true,writable:true},
            vistor:{
              set:function(val){
                this.age  = val; // 这里一定要添加this，别人不能正常修改
                alert("调用了setter")
              },
              get:function(){
                return this.age; // 这里一定要添加this
              },
              configurable:true,
              enumerable:true
            }
          });
          person.vistor = 100 ; // val = 10
          // alert(person.age);
          alert(person.vistor); // return age, age = 100
       ```

   ###  6.1.3 读取属性的特性

   - Object.getOwnPropertyDescriptor()方法，可以获取给定属性的描述符

     ```javascript
        var person = {age:10};
        Object.defineProperties(person,{
          name:{value:"libaison"},
          age:{value:10},
          vistor:{
            set:function(val){
              this.age  = val; // 这里一定要添加this，别人不能正常修改
              alert("调用了setter")
            },
            get:function(){
              return this.age + 10; // 这里一定要添加this
            }
          }
        });
        var objVal = Object.getOwnPropertyDescriptor(person,'age');
        alert(objVal.value); // 10;
        alert(objVal.configurable); // true
     
       var objVal = Object.getOwnPropertyDescriptor(person,"vistor");
       alert(objVal.configurable); // false 不能随意对访问器属性进行修改 
       alert(objVal.writable); // undefined
       alert(objVal.enumerable); // false
       alert(objVal.get); // function
     ```



## 6.2 创建对象 

- 虽然构造函数或字面量都可以来创建单个对象，但是这些方式都有一个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式来创建

### 6.2.1 工厂模式

- 工厂模式是一种设计模式，这种模式抽象了创建具体对象的过程。

  ```javascript
   function creatObject(name,age,job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        return o;
      }
      var person = creatObject('libaison',8,"ceo");
      alert(person.name); // libaison
      alert(person.age); // 8
      alert(person.job);  // ceo
  
    alert(person.constructor == CreatObject); // true
  
  // 这种方法虽然是可以大规模的创建函数，但是没有方法去识别对象。
  // 于是引入了构造函数模式
  ```

### 6.2.2 构造函数模式

- 构造函数没有显示的的创建对象

- 直接将属性和方法赋给了this对象

- 没有return语句

  ```javascript
   function Person(name,age){
          this.name = name;
          this.age = age;
          this.sayName =function() {
            alert(this.name);
          }
      }
      var person = new Person("libaisonm",18);
      alert(person.name); // libaisonm
      alert(person.age); // 18
      person.sayName();  // libaisonm
  	
    alert(person.constructor == Person); // true
  ```

- 要创建一个Person新实例，必须使用new操作符。以这种方式调用构造函数实际上会经历以下四个步骤

  - 创建一个新对象
  - 将构造函数的作用域赋给新对象（因此这个this就指向了这个新对象）
  - 执行构造函数中的代码
  - 返回新对象 

- 不管是工厂模式或是构造函数模式都是继承Object对象

  1. 把构造函数当作函数

     构造函数和其他函数的唯一区别，就在于调用他们的方法不一样。

  2. 构造函数的问题

     ```javascript
     function Person(name,age){
            this.name = 'libaisonm'；
            this.age = 10；
            this.sayHello = new Function("alert('hello worldd')")； //这与函数的声明是一致的 
         }
         var person = new Person();
         alert(person.name);
         person.sayHello(); 
         
         function Person(name,age){
            this.name = 'libaisonm',
            this.age = 10,
            this.sayHello = sayHello;
         }
         function sayHello(){
           alert("hello")
         }
         // 这样创建的话每个对象中的函数副本都是一样的
       
     ```



### 6.2.3 原型模式

- 我们创建的每一个函数都有一个prototype属性，这个属性是一个指针，指向一个对象。而这个对象的用途是包括特定类型的所有实例共享的方法和属性。

  ```javascript
  function Person(){};
     Person.prototype.name = "sss";
     Person.prototype.age = 10;
     Person.prototype.job = "ceo";
     Person.prototype.sayHello = function(){
       alert('hello');
     }
     var person = new Person();
     alert(person.name); // sss
     alert(person.age); // 10
     person.sayHello(); // hello
  ```

  1. 理解原型对象

     - 无论什么时候，只要创建了一个新函数，就会根据一组特定规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有的原型对象都会自动的获得一个constructor属性，这个属性包含了指向一个指向prototype属性所在函数的指针。即Person.prototype.constructor 指向Person。通过这个函数我们还可以继续为原型对象添加其他属性和方法。

     - 创建自定义的构造函数后，其原型对象会自动获取constructor属性；而其他属性都是从Object继承而来的。

       ![image-20210202145815801](C:\Users\Libaisonm\AppData\Roaming\Typora\typora-user-images\image-20210202145815801.png)

     - Person的每个实例——person1和person2都含有一个内部属性。该属性指向Person.prototype,换句话说，它们与构造函数没有自己关系。但是他们可以访问原型里的属性和方法。这是通过查找对象属性的过程来实现的。

     - isPrototype()方法来确定函数和原型之间是否存在所属关系。

       ```javascript
       function Person(){};
          Person.prototype.name = "sss";
          Person.prototype.age = 10;
          Person.prototype.job = "ceo";
          Person.prototype.sayHello = function(){
            alert('hello');
          }
          var person1 = new Person();
          alert(Person.prototype.isPrototypeOf(person1)); // true
          // 这个方法是存在于原型对象中的 -- 从Object对象继承得来的
       
          alert(Object.getPrototypeOf(person) == Person.prototype); // true
          alert(Object.getPrototypeOf(person).name); // sss
       // 这个方法可以获取一个对象的原型
       ```

     - 我们可以通过实例来获取原型中的值，但是不能修改元素中值

       ```javascript
        function Person(){};
          Person.prototype.name = "sss";
          Person.prototype.age = 10;
          Person.prototype.job = "ceo";
          Person.prototype.sayHello = function(){
            alert('hello');
          }
          var person = new Person();
          var person2 = new Person();
           person.name = 'aaa';
           alert(person.name); // aaa 这是修改的对象实例中的属性
           alert(person2.name); // sss
            Person.prototype.name = 'aaa'; // 构造函数可以正确的修改原型的属性和方法
          person2.prototype.name = 'aaaa'; // 这样是错误的
           alert(person2.name) ;
       ```

     - 判断原型中是否存在某个实例属性

       ```javascript
       function Person(){};
          Person.prototype.name = "sss";
          Person.prototype.age = 10;
          Person.prototype.job = "ceo";
          Person.prototype.sayHello = function(){
            alert('hello');
          }
          var person1 = new Person();
          
          var person2 = {
            name:'qqq',
          }
          alert(person2.hasOwnProperty('name')); // true
          alert(person1.hasOwnProperty('name')); // false
          person1.name = 'aaaa';
          alert(person1.hasOwnProperty('name')); // true
       
       // 只有当实例中存在该属性是才会返回true
       ```

       ![image-20210202152812766](C:\Users\Libaisonm\AppData\Roaming\Typora\typora-user-images\image-20210202152812766.png)

  2. 原型和in操作符

     - 有两种方法使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问的给定属性时返回true，无论该属性是在实例中还是在原型中。

       ```javascript
       function Person(){};
          Person.prototype.name = "sss";
          Person.prototype.age = 10;
          Person.prototype.job = "ceo";
          Person.prototype.sayHello = function(){
            alert('hello');
          }
          var person1 = new Person();
          var person2 = new Person();
          
          alert(person1.hasOwnProperty('name')); // false
          alert('name' in person1); // true
          // 这个是存在于实例
       
       	function hasPrototypeProperty(object,name){
               return object.hasOwnPrototype(name) && (name in object);
               // 判断属性是不是在原型当中
           }
       ```

     - 在使用for-in循环时，返回的是所有能够通过对象访问的，可枚举的属性。其中既包括存在于实例中的属性，也包括存在于原型中的属性。根据规定，所有开发人员定义的属性都是可枚举的

     - 要取得对象上所有可枚举的实例属性，可以使用Object.keys()方法

       ```javascript
        function Person(){};
          Person.prototype.name = 'sss';
          Person.prototype.age = 18;
          Person.prototype.job = 'ceo';
          Person.prototype.sayName = function(){
            alert(this.name); 
          }
       
          var keys = Object.keys(Person.prototype);
          alert(keys);  // name,age,job,sayName
           var p1 = new Person();
           p1.name = 'aaa';
           p1.age = 8;
           alert(Object.keys(p1)); // name,age
       ```

     - Object.getOwnPropertyNames()方法可以获取所有的实例属性

       ```javascript
       function Person(){};
          Person.prototype.name = 'sss';
          Person.prototype.age = 18;
          Person.prototype.job = 'ceo';
          Person.prototype.sayName = function(){
            alert(this.name); 
          }
       
          var keys = Object.getOwnPropertyNames(Person.prototype);
          alert(keys); // constructor,name,age,job,sayName
       ```

  3. 更简单的原型语法

     ```javascript
     function Person(){};
       Person.prototype = {
         name:'aaa',
         age:10,
         job:'ceo',
         sayName:function(){
           alert(this.name);
         }
       } 
         var p = new Person();
         alert(p instanceof Person); // true;
         alert(p instanceof Object); // true;
         alert(p.constructor == Person) // false
         alert(p.constructor == Object); // true
     // 这样设置的话constructor不再指向构造函数对象
        // 需要自己手动设置
     
     function Person(){};
       Person.prototype = {
         name:'aaa',
         age:10,
         job:'ceo',
         sayName:function(){
           alert(this.name);
         }
       }
         Object.defineProperty(Person.prototype,'constrctor',{
            enumerable:false,
            value:Person
         })
     
     alert(p.constrctor == Person);  // true
        
     ```

  4. 原型的动态性

     - 由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能立即从实例上反应出来。

       ```javascript
       var Person = function(){};
         var p = new Person();
          Person.prototype.name = 'sss';
          Person.prototype.sayName = function(){alert(this.name)};
         
          p.sayName();  // sss
       ```

     - 尽管可以随时为原型添加属性和方法，并且修改可以在对象实例中马上反应出来，但是如果重写整个原型对象，那么情况就不一样了。

       ```javascript
       var Person = function(){}; // 这里的原型已经绑定
         var p = new Person(); 
         Person.prototype.name = "hello"; //这个原型和下面这个原型已经不一样了
         Person.prototype = { // 这里会重新定义一个原型，手动绑定原来的构造函数对象
           // 这个原型表示已经不是原来的构造函数对象指向的原型
           constructor:Person,
           name:'aaa',
           age:10
         };
         
         alert(p.name);  // undefined
       ```

     - 重写原型对象会切断与原来构造函数对象的的联系

       ![image-20210202181607108](C:\Users\Libaisonm\AppData\Roaming\Typora\typora-user-images\image-20210202181607108.png)

  5. 原生对象的的原型

     - 原型模式的重要性不仅体现在创建自定义类房买你，就连所有的原生的引用类型，都是采用这种模式创建的

     - 所有的原生引用类型都在其构造函数的原型上定义了方法

       ```javascript
        alert(typeof Array.prototype.sort); // function
           alert(typeof String.prototype.substring); // function
       
       ```

     - 通过原生对象的原型，不仅仅可以获得所有默认方法的引用，而且可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。

       ```javascript
        String.prototype.startsWith = function(txt){
             return this.indexOf(txt) == 0;
         }
         var msg = "hello world";
         alert(msg.startsWith("hello")); // true
       // 这样在原生对象添加一个方法或属性的方法并不值得推荐
       ```

  6. 原生对象的问题

     - 原生对象也不是没有缺点

       1. 它省略了为构造函数传递初始化参数的这一环节

       2. 原型模式的最大问题是由其共享的本性导致的

          ```javascript
          function Person(){}; // 构造函数
              Person.prototype = {
                constructor:Person,
                name:"sss",
                age : 29,
                job:"ceo",
                friend:['aaa','bbb'],
                sayName:function(){
                  alert(this.name);
                }
              }
              var person1 = new Person();
              var person2 = new Person();
              
              person1.friend.push('ccc');
              alert(person1.friend);  // aaa,bbb,ccc
              alert(person2.friend); // aaa,bbb,ccc
              alert(person2.friend == person1.friend); // true 
          
          // 这样的共享性质会导致一些问题
          ```



### 6.2.4 组合使用构造函数模式和原型模式

- 创建自定义类型最常见的方式，就是组合使用构造函数和原型模式。

- 构造函数模式用来定义实例属性

- 原型模式用来定义方法和共享的属性

  ```javascript
  function Person(name,age,job){
       this.name = name;
       this.age = age;
       this.job = job;
       this.friends = ['xx','yy'];
     }
     Person.prototype = {
       constructor:Person, // 这样原型是指向所有的Person的
      // 这里面的的所有函数都是Person共享的
      sayName:function(){
        alert(this.name);
      }
     }
     var person1 = new Person('aa',10,'ceo');
     var person2 = new Person('bb',18,'cto');
     person1.friends.push('zz');
     alert(person1.friends); // xx,yy,zz
     alert(person2.friends); // xx,yy
     
     alert(person2.friends == person1.friends); // false
     alert(person1.sayName == person2.sayName); // true
  ```



### 6.2.5 动态原型模式

- 动态原型模式致力于把所有的信息都封装在构造函数中，而通过构造函数中初始化原型，右保持了使用构造函数和原型的优点。

  ```javascript
   function Person(name,age,job){
        this.name = naem;
        this.age = age;
        this.job = job;
        if(typeof this.sayName != 'function'){ // 这样判断之后就只会执行一次
          Person.prototype.sayName = function(){ 
            alert(this.name);
          }
        }
      }
  ```



### 6.2.6 寄生构造函数模式

- 通常，在前述的几种模式都不适用的情况下，可以使用寄生构造函数模式。

- 这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象

- 从表面上看，这个函数有很像是典型的构造函数

  ```javascript
   function Person(name,age,job){
       var o = new Object();
       o.name = name;
       o.age = age;
       o.job = job;
       o.sayName = function(){
         alert(o.name);
       }
       return o;
     }
  	var p = new Person('sss',10,'ceo');
  // 这个模式可以在特殊情况下用来为对象创建构造函数
  
  // 创建一个具有特殊属性和方法的Array构造函数
    function spacailArr(){
      var arr = new Array();
      arr.push.apply(arr,arguments);
  
      arr.toJ = function(){
        return arr.join('|');
      }
      return arr;
    }
    var arr = new spacailArr('aaa','bbb','ccc','ddd');
    alert(arr);  // aaa,bbb,ccc,ddd
   alert(arr.toJ()); // aaa|bbb|ccc|ddd
   alert(arr instanceof Array); // true
   alert(arr instanceof spacailArr); // fasle
  
  // 该对象跟创建对象的寄生函数名没有关系，这个对象仍然是Array而不是spacailArr
  ```

- 关于寄生函数模式：

  1. 返回的对象和构造函数或者与构造函数的原型属性没有关系
  2. 构造函数返回的对象跟在外面的创建的对象没有区别



### 6.2.7 稳妥构造函数模式

- 稳妥对象：指没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中使用

  ```javascript
   function Person(name,age,job){
        var o = new Object(); // 创建要返回的对象
        // 这里可以定义私有变量和方法
        o.sayName = function(){
          alert(name);
        }
        return o;
      }
  
  // 这种模式创建的对象，除了使用sayName方法以外，没有其他办法来访问name的值
  
  var p = Person('ss',10,'ceo');
  p.sayName();// 这样可以很安全的使用对象的方法
  ```



## 6.3 继承

- JavaScript只是支持实现继承，而且其实现继承主要是依赖原型链来实现的

### 6.3.1 原型链

- JavaScript中描述原型链的概念，并将原型链作为实现继承的主要方法

  ```javascript
  function SuperType(){
    this.property = true;
  }
  SuperType.prototype.getSuperValue = function(){
    return this.property; // 这是定义再最顶层从原型对象方法
  }
  function SubType(){
     this.subproporty = false;
  }
  
  // 继承了SuperType
  SubType.prototype = new SuperType(); // 继承
  
  SubType.prototype.getSubValue = function(){
    return this.subproperty; // 这个属性是在SuperType中
  }
  var instance = new SubType();
  alert(instance.getSuperValue); // true
  // 注意重写constructor 
  // 现在的constructor指向的是SuperType
  // 原来的constructor被重写了（undefined）
  ```

  ![image-20210202220914290](C:\Users\Libaisonm\AppData\Roaming\Typora\typora-user-images\image-20210202220914290.png)

  1. 别忘记默认的原型

     在引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例，因此默认原型都会包含一个内部指针，指向Object.prototype。

  2. 确定原型和实例的关系

     ```javascript
     alert(instance instanceof SuperType); // true
     alert(instance instanceof SubType); // true
     alert(instance instanceof Object); // true
     
     alert(Object.prototype.isPrototypeOf(instanc)); // true
     alert(SuperType.prototype.isPrototypeOf(instance)); // true
     alert(SubType.prototype.isPrototypeOf(instanc)); // true
     ```

  3. 谨慎的定义方法

     - 子类型有时需要重写超类型的某个方法，或者需要添加超类型中某个不存在的方法，但不管怎么样，给原型添加方法的代码一定要放在替换原型的语句之后。

       ```javascript
        function SuperType(){
             this.property = true;
           }
           SuperType.prototype.getSuperValue = function(){
             return this.property;
           }
           function  SubType(){
             this.subproperty = false;
           }
           // 继承了SuperType
           SubType.prototype = new SuperType();
           // 添加新方法
           SubType.prototype.getSubValue = function(){
             return this.subproperty;
           }
           // 重写超类中的方法
           SubType.prototype.getSuperValue = function(){
             return false;
           }
             var in2 = new SuperType(); 
             var in1 = new SubType(); 
             alert(in2.getSuperValue()); // true
         
             alert(in1.getSuperValue()); // false
             alert(SubType.prototype.getSuperValue()); // fasle
       
       // ** 在实例替换原型之后再定义两个方法
       	
       ```

     - 不能使用字面量来创建原型方法

       ```javascript
       function SuperType(){
             this.property = true;
           }
           SuperType.prototype.getSuperValue = function(){
             return this.property;
           }
           function  SubType(){
             this.subproperty = false;
           }
           // 继承了SuperType
           SubType.prototype = new SuperType();
           
           // 使用字面量添加新方法，会导致继承无效
           SubType.prototype = {
             getSubValue:function(){
               return this.subproperty;
             },
             someOtherM:function(){
               return false;
             }
           }
           // 这样会导致原型重写
           var instance = new SubType(); // 
           alert(instance.getSuperValue()); // error 
       ```

  4. 原型链的问题

     - 使用原型链实现继承时也存在一些问题。其中最大的问题来自包含引用类型值的原型

       ```javascript
       function  SuperType(){
            this.colors = ['red','blue','green'];
          }
          function SubType(){
       
          }
          // 继承了SuperType
          SubType.prototype = new SuperType(); 
       
          var instance01 = new SubType();
          instance01.colors.push('black');
          alert(instance01.colors);  // red blue green black
       
          var instance02 = new SubType();
          alert(instance02.colors); // red blue green black
       ```

     - 在创建子类型的实例时，不能向超类类型的构造函数中传递参数。



### 6.3.2 借用构造函数

```javascript
function SuperType(){
      this.colors = ['red','green','blue'];
    }
    function SubType(){
      SuperType.call(this); 
    }
    var instance01 = new SubType();
    instance01.colors.push('black'); // red blue green black

    var instance02 = new SubType();
    alert(instance02.colors); // red blue green

    // 这样的执行每一个子类都会有自己的副本
```

1. 传递参数

   - 相对于原型链来说，借用构造函数有一个很大的优势，就是可以在子类中调用超类的构造函数传递参数

     ```javascript
     function SuperType(name){
           this.name = name;
         }
         function SubType(){
           SuperType.call(this,"libaison");
         }
         var p1 = new SubType();
         alert(p1.name); // libaison
     ```

2. 借用构造函数的问题

   - 这样做的话，代码复用就无从谈起



### 6.3.3 组合继承

- 也称为伪经典继承

  ```javascript
   function SuperType(name){
        this.name = name;
        this.colors = ['red','blue','green'];
      }
      SuperType.prototype.sayName = function(){
        alert(this.name); // 这是共享的方法
      }
  
      function SubType(){
        SuperType.call(this,'libaison');
      }
      SubType.prototype = new SuperType();
  
      var p = new SubType('liabsion');
  
      alert(p.colors); //['red','blue','green']
      p.sayName();  // libaisonm
  
  // 这是最常用的继承方法
  ```



### 6.3.4 原型式继承

- 借助原型可以基于已有的对象创建新对象

  ```javascript
    function object(o){ // o是已有的对象
        function F(){};
        F.prototype = o;
        return new F();
      }
  // o作为一个对象参数只是一个浅复制
  
  function object(obj){
        function F(){};
        F.prototype = obj;
        return new F();
      }
  
      var person = {
        name:'sss',
        colors:['red','pink','green']
      }
      var obj = object(person);
      obj.age = 10;
      obj.colors.push('black');
      alert(obj.colors);  // red,pink,green,black
  
      var obj2 = object(person);
      obj2.colors.push('grey'); 
      alert(obj2.colors); // red,pink,green,black,grey
  
  ```

- JavaScript新增了继承方法

  ```javascript
  
      var person = {
        name:'sss',
        colors:['red','pink','green']
      }
      var obj1 = Object.create(person);
      obj1.colors.push('black');
      alert(obj1.colors);  //  red,pink,green,black
  
      var obj2 = Object.create(person);
      obj2.colors.push("grey");
      alert(obj2.colors);  // red,pink,green,black,grey
  	
  	var obj3 = Object.create(person,{
        age:{
          value:10
        }
      });
      alert(obj3.age);  // 10
  
  
  ```



### 6.3.5 寄生式继承

```JavaScript
function ctreatObj(obj){
        var res = Object.create(obj);
        res.sayName = function(){
          alert(this.name)
        }
      }
```



### 6.3.6 寄生组合式继承

```javascript
function SuperType(name){
        this.name = name;
        this.colors = ['red','blue','pink']
      }
      SuperType.prototype.sayName = function(){
        alert(this.name);
      }
      function SubType(name,ag){
         SuperType.call(this.name); // 第一次调用SuperType
         this.age = age;
      }

      SubType.prototype = new SuperType(); // 第二次调用
      SubType.prototype.constructor = SubType;
      SubType.prototype.sayAge = function(){
        alert(this.age);
      }
    
```

- 所谓寄生组合式继承，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给于类型原型。寄生组合式继承的基本模式如下所示。

  ```javascript
      function  inherit(subType,superType){ 
       var por = Object.create(superType.prototype);
       por.constructor = subType;
       subType.prototype = por; 
      }
  ```

- 这样做会少调用一次构造函数，提高了效率

  ```javascript
   function  inherit(subType,superType){ 
       var por = Object.create(superType.prototype);
       por.constructor = subType;
       subType.prototype = por; 
  
       // por作为一个中间副本
      }
        function SuperType(name){
          this.name = name;
          this.colors = ['red','blue','green'];
        }
        SuperType.prototype.sayName = function(){
          alert(this.name);
        }
        function SubType(name,age){
          SuperType.call(this,name);
          this.age = 10;
        }
        inherit(SubType,SuperType);
  
  // 这被认为是最理想的的继承范式
  ```

  